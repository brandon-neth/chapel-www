<!DOCTYPE html>

<html data-theme="light" lang="en"><head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<meta content="#00cbff" name="theme-color"/>
<meta content="This post gives a beginner’s introduction to Chapel’s GPU programming features" name="description"/>
<link href="//cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css" media="screen,print" rel="stylesheet"/>
<link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css" integrity="sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X" rel="stylesheet"/>
<style>.sidenote-checkbox { display: none; }</style>
<style>.feather { width: 1rem; height: 1rem; }</style>
<link href="../../scss/style.min.css" media="screen,print" rel="stylesheet"/>
<link href="../../scss/sidenotes.min.css" media="screen,print" rel="stylesheet"/>
<link href="../../css/syntax.min.css" media="screen,print" rel="stylesheet"/>
<link href="../../scss/syntax-terminal.min.css" media="screen,print" rel="stylesheet"/>
<link href="../../scss/code.min.css" media="screen,print" rel="stylesheet"/>
<link href="../../img/favicon.ico" rel="icon" type="image/png"/>
<script defer="" src="../../js/dropdown-menu.js"></script>
<title>Introduction to GPU Programming in Chapel</title>
</head>
<body>
<header>
<div class="container">
<a class="site-title" href="../../">
<img alt="Chapel logo" height="50" src="../../img/logo.png" width="50"/>
<h1>Chapel Language Blog</h1>
</a>
</div>
<nav id="Header">
<div class="container">
<a href="../../about">About</a>
<a href="https://chapel-lang.org">Chapel Website</a>
<a href="../../featured">Featured</a>
<a href="../../series">Series</a>
<a href="../../tags">Tags</a>
<a href="../../authors">Authors</a>
<a href="../../posts">All Posts</a>
</div>
</nav>
</header>
<main class="container">
<h2>Introduction to GPU Programming in Chapel</h2>
<div class="post-subscript">
<p>Posted on January 10, 2024.</p>
<p>
        Tags:
        
        <a class="button" href="../../tags/gpu-programming">GPU Programming</a>
<a class="button" href="../../tags/how-to">How-To</a>
</p>
<p>
    By:
    <a href="../../authors/daniel-fedorin">Daniel Fedorin</a>
</p>
</div>
<div class="post-content">
<div class="table-of-contents">
<div class="wrapper">
<span class="header">Table of Contents</span>
<nav id="TableOfContents">
<ul>
<li><a href="#locales-and-on-statements-the-foundation-of-chapel">Locales and <code>on</code> Statements: The Foundation of Chapel</a></li>
<li><a href="#what-else-can-you-do-on-a-gpu">What Else Can You Do on a GPU?</a></li>
<li><a href="#where-can-i-run-chapel-code-for-gpus">Where Can I Run Chapel Code for GPUs?</a></li>
<li><a href="#summary">Summary</a></li>
<li><a href="#appendix-what-sorts-of-problems-benefit-from-gpus">Appendix: What Sorts of Problems Benefit from GPUs?</a></li>
</ul>
</nav>
</div>
</div>
<p>Chapel is a programming language for productive parallel computing.
In recent years, a particular subdomain of parallel computing has exploded
in popularity: GPU computing. As a result, the Chapel team has been hard at
work adding GPU support, making it easy to create vendor-neutral and performant
GPU programs. This aspect of the Chapel compiler has seen rapid improvements since
its initial release, and continues to receive enhancements and performance fixes over time.
This tutorial will provide an introduction to Chapel’s GPU programming features.</p>
<p>Although frameworks such as CUDA and HIP are commonly used for programming
GPUs, this tutorial does not assume familiarity with them. Examples will
make use of some general-purpose features of Chapel, and this post will
explain them along the way. For a more deliberate introduction to Chapel,
see the <a href="../../series/advent-of-code-2022/">Advent of Code</a> series on this blog,
or check the <a href="https://chapel-lang.org/learning.html" rel="noopener" target="_blank">Learning Chapel</a> page
for more resources.</p>
<p>In this post, we’ll jump right in to using Chapel’s GPU programming features. If
you’re interested in a refresher on what problems GPUs are useful for,
check out the <a href="#appendix-what-sorts-of-problems-benefit-from-gpus"><em>Appendix</em> section containing this information</a>.</p>
<h3 id="locales-and-on-statements-the-foundation-of-chapel">
<a href="#locales-and-on-statements-the-foundation-of-chapel">Locales and <code>on</code> Statements: The Foundation of Chapel</a>
</h3>
<p>When GPUs are in play, it’s possible for code to be executing
in different places: it could be running either on a CPU, as most programmers
are used to, or on a GPU. GPUs and CPUs differ significantly;
code well-suited for one may not be well-suited for the other.
Chapel gives the programmer control over where their code is running through
its notion of <em>locales</em>. Quoting from the
<a href="https://chapel-lang.org/docs/primers/locales.html" rel="noopener" target="_blank">Chapel specification</a>:</p>
<blockquote>
<p>In Chapel, the <code>locale</code> type refers to a unit of the machine resources on
which your program is running.</p></blockquote>
<p>In other words, a locale is a part of the computer that can run code;
this might represent a GPU or a CPU. Chapel’s <em><code>on</code> statement</em>, when given
a locale, can be used to explicitly state where a particular piece of code
should be executed. For example, the following code computes and prints the
even numbers up to ten, running the computation on the first GPU locale.</p>
<div class="highlight" data-code-path="code/intro-to-gpus.chpl" data-code-section="middle" data-code-type="main" data-start-line="1"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma" tabindex="0"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma" tabindex="0"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="kd">config</span><span class="w"> </span><span class="kd">const</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// use 5-element arrays in examples by default, for brevity
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">on</span><span class="w"> </span><span class="nx">here</span><span class="p">.</span><span class="nx">gpus</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">A</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w"> </span><span class="c1">// declare an array with n elements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">                     </span><span class="c1">// (to benefit from GPUs, you'd probably want n &gt;&gt; 5)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">foreach</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="w"> </span><span class="k">do</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">A</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">"The whole array A is: "</span><span class="p">,</span><span class="w"> </span><span class="nx">A</span><span class="p">);</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="w"> </span><span class="k">do</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">"A["</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="s">"] = "</span><span class="p">,</span><span class="w"> </span><span class="nx">A</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="good-menu">
<div class="good-label">Console output</div>
<div class="highlight"><pre class="chroma" tabindex="0"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="go">The whole array A is: 2 4 6 8 10
</span></span></span><span class="line"><span class="cl"><span class="go">A[1] = 2
</span></span></span><span class="line"><span class="cl"><span class="go">A[2] = 4
</span></span></span><span class="line"><span class="cl"><span class="go">A[3] = 6
</span></span></span><span class="line"><span class="cl"><span class="go">A[4] = 8
</span></span></span><span class="line"><span class="cl"><span class="go">A[5] = 10
</span></span></span></code></pre></div>
</div>
<p>The code starts with an <code>on</code> block targeting a GPU <em>sub-locale</em>.
This block references <code>here</code>, a special variable that refers to the
locale currently running the code. When GPU support is enabled, locales
include a field called <code>gpus</code>, which is an array of sub-locales, each
representing an installed GPU. On a locale with a single GPU, <code>here.gpus</code>
will be a single-element array. On locales with more than one GPU (which is
<span class="sidenote"><label class="sidenote-label" for="sidenote-0">common in supercomputers</label><input class="sidenote-checkbox" id="sidenote-0" type="checkbox"/><span class="sidenote-content sidenote-right" style="margin-top: -4.5rem"><span class="sidenote-delimiter">[note:</span>I mentioned supercomputers here for a reason. Chapel’s GPU support
has been tested on large machines, including Frontier, the only
exascale supercomputer in the TOP500 list at the time of publishing.<span class="sidenote-delimiter">]</span></span></span>), <code>here.gpus</code> will have as many elements as
there are GPUs. Thus, <code>here.gpus[0]</code> is the machine’s first GPU.</p>
<details>
<summary><strong>(How do I enable GPU support?)</strong></summary>
<div style="padding-left: 2vw; padding-right: 2vw; padding-bottom: 2ch;">
<p>To enable GPU support, Chapel must be built with with the <code>CHPL_LOCALE_MODEL</code>
environment variable set to <code>gpu</code>. In a Bash session, the variable can be
set as follows:</p>
<div class="highlight"><pre class="chroma" tabindex="0"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">CHPL_LOCALE_MODEL</span><span class="o">=</span>gpu
</span></span></code></pre></div><p>If you have an NVIDIA GPU, this should be enough to compile and run GPU-enabled
programs. For AMD GPUs, you will also need to specify your GPU’s architecture
using the <code>CHPL_GPU_ARCH</code> environment variable:</p>
<div class="highlight"><pre class="chroma" tabindex="0"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">CHPL_GPU_ARCH</span><span class="o">=</span>your_arch_here
</span></span></code></pre></div><p>Finally, even if you don’t have a GPU, Chapel provides a mode called
‘cpu-as-device’. In this mode, you still get a <code>here.gpus</code> array, and
can write code targeting GPUS; however, your computer’s CPU will be used
to execute all code. This makes it possible to develop GPU-enabled programs
without access to a GPU. Setting the <code>CHPL_GPU</code> environment variable to
<code>cpu</code> enables ‘cpu-as-device’ mode:</p>
<div class="highlight"><pre class="chroma" tabindex="0"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">CHPL_GPU</span><span class="o">=</span>cpu
</span></span></code></pre></div><p>Please see the page on <a href="https://chapel-lang.org/docs/usingchapel/building.html" rel="noopener" target="_blank">building chapel</a>
as well as the <a href="https://chapel-lang.org/docs/technotes/gpu.html" rel="noopener" target="_blank">GPU technical note</a>
for more information on GPU-related environment variables.</p>
</div>
</details>
<p>The code generates even numbers by iterating over the indices
one through five, multiplying each by two. GPUs are good at solving the same
sub-problem many times in parallel; doubling each number can be its own sub-problem,
making the loop in the example well-suited for GPU execution. The multiplication
loop is written using the <code>foreach</code> keyword, which tells Chapel that it
is safe to execute in parallel. The language takes care of the rest.
Chapel has traditional <code>for</code> loops as well, like the second loop in the example.
We’ll talk about the difference between the two further down.</p>
<p>Whereas the <code>foreach</code> loop in the example runs on the GPU, the <code>writeln</code>
on line 9
doesn’t. Unlike the multiplications, printing a single string to the
console is not a good match for the GPU. Generally, code that’s
suitable for GPU execution can be broken up into many similar and independent
pieces. For a loop, this translates into <em>order-independence</em>. A loop
is order-independent if no iteration affects any of the others.
Thinking back to our example, let’s examine the multiplication loop again:</p>
<div class="highlight"><pre class="chroma" tabindex="0"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="w">  </span><span class="k">foreach</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="w"> </span><span class="k">do</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">A</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>We can observe that the result of <code>5*2</code> does not affect the
computation of <code>3*2</code>. Each iteration accesses a different element of <code>A</code>,
so there are no data races. Thus, our example is an instance of an
order-independent loop. Chapel leaves it up to the programmer to indicate
which loops have this property; to assert that a loop is order-independent, it
should be written <span class="sidenote"><label class="sidenote-label" for="sidenote-1">using the <code>foreach</code> keyword.</label><input class="sidenote-checkbox" id="sidenote-1" type="checkbox"/><span class="sidenote-content sidenote-right"><span class="sidenote-delimiter">[note:</span>Chapel also features <code>forall</code> loops. These loops allow the
the data structure being traversed to decide how iteration is parallelized.
Data structures that ship with the Chapel standard library are smart enough
to make use of order-independence, so an eligible <code>forall</code> loop on
a GPU locale would also be executed on the GPU.<br/><br/>See the <a href="https://chapel-lang.org/docs/main/primers/loops.html" rel="noopener" target="_blank">loops primer</a>
to learn more about Chapel’s various types of loops.<span class="sidenote-delimiter">]</span></span></span></p>
<p>It’s not hard to see why order-independent loops lend themselves well to
GPU execution. If it doesn’t matter in what order the loop’s iterations are executed, then
we can think of each iteration as an independent sub-problem to be handed off
to a GPU core. This observation is the foundation of Chapel’s GPU support:
<strong>order-independent loops can be executed in parallel on the GPU</strong>. In fact,
Chapel will automatically convert order-independent loops into GPU code
whenever it can.</p>
<details>
<summary><strong>(I know CUDA/HIP. Can you tell me more about how this works?)</strong></summary>
<div style="padding-left: 2vw; padding-right: 2vw; padding-bottom: 2ch;">
<p>In CUDA and HIP, writing a GPU-enabled program generally involves creating a function
marked as <code>device</code> or <code>global</code>, and using this function in a
kernel launch. Under the hood, Chapel
does the same.</p>
<p>When Chapel encounters a GPU-eligible loop, it converts its body into a function,
named something like <code>chpl_gpu_kernel_filename_linenumber</code>. If the loop
body / newly defined kernel function contains calls to other functions or
methods, Chapel also generates <code>device</code> versions of these.</p>
<p>Chapel inserts a kernel launch alongside the original loop. Since
the same code could be executed from <code>here.gpus[0]</code> (GPU) or the default
locale (CPU), Chapel preserves the loop as well. Thus, on a GPU it performs
the kernel launch, and on a CPU, it falls back to the loop.</p>
</div>
</details>
<p>In comparison, the second loop in the example is <em>order-dependent</em>.</p>
<div class="highlight"><pre class="chroma" tabindex="0"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="w"> </span><span class="k">do</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">"A["</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="s">"] = "</span><span class="p">,</span><span class="w"> </span><span class="nx">A</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span><span class="w">
</span></span></span></code></pre></div><p>We specifically intend for the elements of <code>A</code> to be printed in order. Because of this,
the iteration that prints the fifth element has to happen after printing the
fourth; there’s a dependency. In Chapel, loops whose iterations need to be
executed one after another (called <em>serial loops</em>) are written using the <code>for</code>
keyword. Loops written using <code>for</code> are not considered by the compiler for GPU
execution.</p>
<p>We have now scrutinized almost every piece of the example. One significant
piece remains: we also declared an array <code>A</code> to contain the even numbers:</p>
<div class="highlight"><pre class="chroma" tabindex="0"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="k">on</span><span class="w"> </span><span class="nx">here</span><span class="p">.</span><span class="nx">gpus</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">A</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">// ... the rest of the even numbers example
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>An important aspect of the <code>on</code> statement is that variables declared inside an <code>on</code>
block logically live on the locale targeted by the statement. Typically, this
means that it’s faster to access these variables from that same locale,
and slower from other locales. Here’s an example:</p>
<div class="highlight"><pre class="chroma" tabindex="0"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="k">on</span><span class="w"> </span><span class="nx">firstLocale</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">A</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nx">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">   </span><span class="c1">// Cheap to access 'A':
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">              </span><span class="c1">// 'A' is accessed from the same locale that it lives on
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">on</span><span class="w"> </span><span class="nx">anotherLocale</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">   </span><span class="c1">// More expensive to access 'A':
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">                </span><span class="c1">// 'A' is accessed from another locale
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><span class="sidenote"><label class="sidenote-label" for="sidenote-2">Currently,</label><input class="sidenote-checkbox" id="sidenote-2" type="checkbox"/><span class="sidenote-content sidenote-right"><span class="sidenote-delimiter">[note:</span>In the future, Chapel aims to make it possible for GPU code to access arrays
declared outside of the GPU locale. However, this would require some
communication between the GPU and CPU, initiated by the GPU. <em>GPU-driven
communication</em> like that is on our roadmap, but not supported at the
time of writing.<span class="sidenote-delimiter">]</span></span></span>
to make an array accessible from code that runs on the GPU (such as
our <code>foreach</code> loop), the array must live on the GPU locale. This is why
we declare <code>A</code> inside the <code>on</code> block, rather than outside of it. Had <code>A</code>
been declared outside the <code>on</code> block, it would’ve been on the CPU locale,
allocated in CPU memory.</p>
<p>Now we’ve gone over the whole introductory example, demonstrating how GPUs
can be targeted in Chapel using <code>on</code> blocks and <code>foreach</code> loops. However, this example
is a very simple program, meant to introduce key concepts in Chapel’s
GPU support. What we’ve seen so far is only the beginning. In the next
section, we’ll take a look at other features of Chapel that mesh seamlessly
with GPU programming.</p>
<h3 id="what-else-can-you-do-on-a-gpu">
<a href="#what-else-can-you-do-on-a-gpu">What Else Can You Do on a GPU?</a>
</h3>
<p>A large portion of the Chapel language can run on the GPU. In this section,
I’ll give a bit of a whirlwind tour of what can be done. To learn more about
the individual language features I’ll be showing off, please take a look
at the resources mentioned at the beginning of this article.</p>
<p>As we go through examples, the reader might wonder: how can we be sure that
the code ran on the GPU? Tracking which code runs where is a slightly more
advanced topic. For the sake of simplicity, I will define a custom function,
<code>numKernelLaunches</code>. The word <em>kernel</em> typically refers to bits of
code that run on a GPU. A <em>kernel launch</em> is the process of a CPU starting
the execution of a kernel on the GPU. You don’t have to understand how my helper
function works; it’s sufficient to think of <code>numKernelLaunches</code> as
returning the total number of kernel launches since the last time we checked.
I’ll be using this function to ensure that code ran on the GPU when we expected
it to.</p>
<details>
<summary><strong>(I do want to see how the function is defined!)</strong></summary>
<div style="padding-left: 2vw; padding-right: 2vw; padding-bottom: 2ch;">
<div class="highlight" data-code-path="code/intro-to-gpus.chpl" data-code-section="middle" data-code-type="main" data-start-line="14"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma" tabindex="0"><code><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma" tabindex="0"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="nx">GpuDiagnostics</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">proc</span><span class="w"> </span><span class="nf">startCountingKernelLaunches</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nx">resetGpuDiagnostics</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nx">startGpuDiagnostics</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">proc</span><span class="w"> </span><span class="nf">numKernelLaunches</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nx">stopGpuDiagnostics</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">reduce</span><span class="w"> </span><span class="nx">getGpuDiagnostics</span><span class="p">().</span><span class="nx">kernel_launch</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nx">startCountingKernelLaunches</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">result</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nx">startCountingKernelLaunches</span><span class="p">();</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div>
</div>
</details>
<p>All examples in this section will be performed on the GPU locale.</p>
<div class="highlight" data-code-path="code/intro-to-gpus.chpl" data-code-section="middle" data-code-type="main" data-start-line="30"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma" tabindex="0"><code><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma" tabindex="0"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="k">on</span><span class="w"> </span><span class="nx">here</span><span class="p">.</span><span class="nx">gpus</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Let’s start with something fun. At the beginning of this article, we used
the GPU to multiply some numbers by two using a <code>foreach</code>. We can do
this even more succinctly using a Chapel feature called
<a href="https://chapel-lang.org/docs/users-guide/datapar/promotion.html" rel="noopener" target="_blank"><em>promotion</em></a>.
Promotion allows us to pass an array to an operation that requires a scalar
value. When we do so, the operation is automatically performed on each element
of the array. This is automatically done in parallel —
potentially on the GPU.</p>
<p>If our operation is “multiply by two”, we can write code as follows:</p>
<div class="highlight" data-code-path="code/intro-to-gpus.chpl" data-code-section="middle" data-code-type="main" data-start-line="32"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma" tabindex="0"><code><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma" tabindex="0"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">Evens</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">Evens</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">// One kernel launch from the promoted initializer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="nx">assert</span><span class="p">(</span><span class="nx">numKernelLaunches</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="good-menu">
<div class="good-label">Console output</div>
<div class="highlight"><pre class="chroma" tabindex="0"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="go">2 4 6 8 10
</span></span></span></code></pre></div>
</div>
<p>In just one simple line, we were able to write code that runs on the GPU.</p>
<p>Let’s move on to our next example. We can call most Chapel functions from
code running on the GPU.
The following example samples the built-in sine function <code>sin</code> on ten
increments within the interval <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>2</mn><mi>π</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0, 2\pi)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mclose">)</span></span></span></span>:</p>
<div class="highlight" data-code-path="code/intro-to-gpus.chpl" data-code-section="middle" data-code-type="main" data-start-line="38"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma" tabindex="0"><code><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre class="chroma" tabindex="0"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="w">  </span><span class="k">use</span><span class="w"> </span><span class="nx">Math</span><span class="p">;</span><span class="w"> </span><span class="c1">// Include the 'Math' module for access to 'sin' and 'pi'
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">numSamples</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..#</span><span class="nx">numSamples</span><span class="p">]</span><span class="w"> </span><span class="nx">sin</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">pi</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">numSamples</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">// One kernel launch from the loop expression initializer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="nx">assert</span><span class="p">(</span><span class="nx">numKernelLaunches</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="good-menu">
<div class="good-label">Console output</div>
<div class="highlight"><pre class="chroma" tabindex="0"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="go">0.0 0.587785 0.951057 0.951057 0.587785 1.22465e-16 -0.587785 -0.951057 -0.951057 -0.587785
</span></span></span></code></pre></div>
</div>
<p>Functions called from the GPU can be user-defined and arbitrarily complex.
In the following example, we use promotion again to compute the first 20 Fibonacci numbers.
This example
<span class="sidenote"><label class="sidenote-label" for="sidenote-3">is not at all optimized,</label><input class="sidenote-checkbox" id="sidenote-3" type="checkbox"/><span class="sidenote-content sidenote-right"><span class="sidenote-delimiter">[note:</span>The example is unoptimized in both an algorithmic and GPU-specific sense.<br/><br/>On the algorithmic side, those familiar with the analysis of algorithms will
likely know that there exists an <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> algorithm to compute the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>th
Fibonacci number. Meanwhile, our naive algorithm is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> — quite bad.
Furthermore, our implementation doesn’t make use of any memoization, performing
a lot of redundant computations between array elements.<br/><br/>On the GPU-specific side, we are writing code that will cause <em>thread
divergence</em>. Each thread will perform a slightly different sequence of steps,
which makes it much harder for the GPU to execute them.<span class="sidenote-delimiter">]</span></span></span>
but serves as a good demonstration of using arbitrary functions in a
kernel, including recursive ones.</p>
<div class="highlight" data-code-path="code/intro-to-gpus.chpl" data-code-section="middle" data-code-type="main" data-start-line="48"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma" tabindex="0"><code><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre class="chroma" tabindex="0"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">fib</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">):</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">fib</span><span class="p">(</span><span class="nx">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">fib</span><span class="p">(</span><span class="nx">x</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">Fibs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">fib</span><span class="p">(</span><span class="mi">0</span><span class="o">..#</span><span class="mi">20</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">Fibs</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">// One kernel launch from the promoted expression in the initializer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="nx">assert</span><span class="p">(</span><span class="nx">numKernelLaunches</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="good-menu">
<div class="good-label">Console output</div>
<div class="highlight"><pre class="chroma" tabindex="0"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="go">1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765
</span></span></span></code></pre></div>
</div>
<p>Here, <code>fib</code> is a normal Chapel function that is being promoted by calling
it with the integer range <code>0..#20</code>.
Note that we are able to use it in a GPU kernel without needing to do anything special.
This is true in general: in Chapel, once a function has been defined, it can be
called from both the GPU and the CPU.</p>
<p>Loops can also be executed as part of a kernel. For our last example, we’ll
define a two-dimensional array <code>Square</code>, then sum each of its columns on
the GPU. The following code will initialize, populate, and print this new
square array:</p>
<div class="highlight" data-code-path="code/intro-to-gpus.chpl" data-code-section="middle" data-code-type="main" data-start-line="59"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma" tabindex="0"><code><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre class="chroma" tabindex="0"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">rows</span><span class="p">,</span><span class="w"> </span><span class="nx">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">Square</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="nx">rows</span><span class="p">,</span><span class="w"> </span><span class="nx">cols</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="nx">r</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">)</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">Square</span><span class="p">.</span><span class="nx">indices</span><span class="w"> </span><span class="k">do</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nx">Square</span><span class="p">[</span><span class="nx">r</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">c</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">"Original array:"</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">Square</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">// Two kernel launches: one from initializing Square, one from the loop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="nx">assert</span><span class="p">(</span><span class="nx">numKernelLaunches</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="good-menu">
<div class="good-label">Console output</div>
<div class="highlight"><pre class="chroma" tabindex="0"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="go">Original array:
</span></span></span><span class="line"><span class="cl"><span class="go">11 12 13 14 15
</span></span></span><span class="line"><span class="cl"><span class="go">21 22 23 24 25
</span></span></span><span class="line"><span class="cl"><span class="go">31 32 33 34 35
</span></span></span><span class="line"><span class="cl"><span class="go">41 42 43 44 45
</span></span></span><span class="line"><span class="cl"><span class="go">51 52 53 54 55
</span></span></span></code></pre></div>
</div>
<p>With the new <code>Square</code> array in hand, we move on to summing its columns. Inside
the <code>foreach</code> loop, we use another <code>for</code> loop as we normally would.</p>
<div class="highlight" data-code-path="code/intro-to-gpus.chpl" data-code-section="middle" data-code-type="main" data-start-line="70"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma" tabindex="0"><code><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span></code></pre></td>
<td class="lntd">
<pre class="chroma" tabindex="0"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">ColSums</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="nx">cols</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">foreach</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">cols</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">rows</span><span class="w"> </span><span class="k">do</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nx">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">Square</span><span class="p">[</span><span class="nx">r</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">ColSums</span><span class="p">[</span><span class="nx">c</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">sum</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">"Column sums:"</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">ColSums</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">// Two kernel launches: one from initializing ColSums, one from the loop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="nx">assert</span><span class="p">(</span><span class="nx">numKernelLaunches</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="good-menu">
<div class="good-label">Console output</div>
<div class="highlight"><pre class="chroma" tabindex="0"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="go">Column sums:
</span></span></span><span class="line"><span class="cl"><span class="go">155 160 165 170 175
</span></span></span></code></pre></div>
</div>
<p>Having gone through a few examples, we can conclude our <code>on</code> block
and return to computing on the CPU.</p>
<div class="highlight" data-code-path="code/intro-to-gpus.chpl" data-code-section="middle" data-code-type="main" data-start-line="85"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma" tabindex="0"><code><span class="lnt">85
</span></code></pre></td>
<td class="lntd">
<pre class="chroma" tabindex="0"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="p">}</span><span class="w"> </span><span class="c1">// end of `on here.gpus[0]`
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Now we have seen several example computations using Chapel’s GPU support.
Where can we run all of this code? Let’s talk about that next.</p>
<h3 id="where-can-i-run-chapel-code-for-gpus">
<a href="#where-can-i-run-chapel-code-for-gpus">Where Can I Run Chapel Code for GPUs?</a>
</h3>
<p>You might recall from the introduction that Chapel’s GPU support is
vendor-neutral. This means that GPU-enabled Chapel code can be executed
on both NVIDIA and AMD GPUs, without any modifications! This includes all
of the code presented in this article.</p>
<p>In fact, you don’t even need a GPU. Chapel supports a mode called ‘CPU-as-device’,
which allows code targeting GPUs to transparently execute on the CPU. You
can prototype GPU-enabled code on a laptop without dedicated graphics, then
switch to a GPU-enabled machine whenever you like. In fact, this is how this
article was written.</p>
<p>Finally, Chapel’s GPU support, like the rest of the language, is scalable.
Programs prototyped on a laptop can easily be executed on a supercomputer,
with good performance. Although writing code in a scalable way requires
<span class="sidenote"><label class="sidenote-label" for="sidenote-4">some additional steps,</label><input class="sidenote-checkbox" id="sidenote-4" type="checkbox"/><span class="sidenote-content sidenote-right"><span class="sidenote-delimiter">[note:</span>Not using only the first GPU via <code>here.gpus[0]</code> is one such step.<span class="sidenote-delimiter">]</span></span></span>
Chapel makes it easy to create parallel code that runs everywhere.</p>
<h3 id="summary">
<a href="#summary">Summary</a>
</h3>
<p>Chapel’s GPU support goes much deeper, but this might be a good stopping point
for an introductory article — we’ve already covered a lot of ground! Let’s
look back at a few of the things we’ve covered:</p>
<ul>
<li>Chapel’s <em>locales</em> represent parts of the machine that can run code and store variables.</li>
<li>The <code>on</code> statement specifies where code should be executed, including on the GPU.</li>
<li><em>Order-independent</em> loops, written using <code>foreach</code>, are automatically executed on the GPU.</li>
<li>Much of the Chapel language can be used in GPU code.
<ul>
<li>This includes <em>promotion</em>, functions plain and recursive, and loops.</li>
</ul>
</li>
<li>All of this is vendor-neutral; Chapel works with both NVIDIA and AMD GPUs.</li>
</ul>
<p>If you’d like to see more information on Chapel’s GPU support in particular,
the <a href="https://chapel-lang.org/docs/technotes/gpu.html" rel="noopener" target="_blank">tech note</a> contains many
details and examples of GPU code, and the
<a href="https://chapel-lang.org/releaseNotes/1.31-1.32/05-gpus.pdf" rel="noopener" target="_blank"><strong>GPU Programming</strong> section of the release notes from Chapel 1.32</a>
contains a “crash course on GPU programming”.</p>
<p>Of course, we have not yet seen a practical example of solving a problem on
the GPU. We also have not yet seen how to analyze the performance of GPU-enabled
programs in Chapel, or how to improve said performance. Finally, we didn’t see
how Chapel’s GPU support frictionlessly integrates with the rest of the language
to allow writing code that runs across all GPUs <strong>and</strong> compute nodes. For
a little sneak peek of that last point, take a look at this version of
the “even numbers” example that runs on all GPUs in the system:</p>
<div class="highlight" data-code-path="code/intro-to-gpus.chpl" data-code-section="middle" data-code-type="main" data-start-line="87"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma" tabindex="0"><code><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span></code></pre></td>
<td class="lntd">
<pre class="chroma" tabindex="0"><code class="language-Chapel" data-lang="Chapel"><span class="line"><span class="cl"><span class="k">coforall</span><span class="w"> </span><span class="nx">loc</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">Locales</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="nx">loc</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">coforall</span><span class="w"> </span><span class="nx">gpu</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">here</span><span class="p">.</span><span class="nx">gpus</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="nx">gpu</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">Evens</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">"Even numbers computed on "</span><span class="p">,</span><span class="w"> </span><span class="nx">gpu</span><span class="p">,</span><span class="w"> </span><span class="s">": "</span><span class="p">,</span><span class="w"> </span><span class="nx">Evens</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="good-menu">
<div class="good-label">Console output</div>
<div class="highlight"><pre class="chroma" tabindex="0"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="go">Even numbers computed on LOCALE0-GPU0: 2 4 6 8 10
</span></span></span><span class="line"><span class="cl"><span class="go">Even numbers computed on LOCALE0-GPU1: 2 4 6 8 10
</span></span></span><span class="line"><span class="cl"><span class="go">Even numbers computed on LOCALE1-GPU0: 2 4 6 8 10
</span></span></span><span class="line"><span class="cl"><span class="go">Even numbers computed on LOCALE1-GPU1: 2 4 6 8 10
</span></span></span></code></pre></div>
</div>
<p>In just six lines of code, we wrote a program that can make use of the
computational resources of an entire supercomputer.</p>
<p>We will be coming back to all of the above topics in subsequent posts,
starting with writing multi-node, multi-GPU programs. Stay tuned!</p>
<p><strong>The entire Chapel program presented in this post can be viewed here:</strong>
<div class="file" data-code-type="main">
<details>
<summary class="file-header">
<a download="intro-to-gpus.chpl" href="./code/intro-to-gpus.chpl">intro-to-gpus.chpl</a>
</summary>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma" tabindex="0"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span></code></pre></td>
<td class="lntd">
<pre class="chroma" tabindex="0"><code class="language-chpl" data-lang="chpl"><span class="line"><span class="cl"><span class="kd">config</span><span class="w"> </span><span class="kd">const</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// use 5-element arrays in examples by default, for brevity
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">on</span><span class="w"> </span><span class="nx">here</span><span class="p">.</span><span class="nx">gpus</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">A</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w"> </span><span class="c1">// declare an array with n elements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">                     </span><span class="c1">// (to benefit from GPUs, you'd probably want n &gt;&gt; 5)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">foreach</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="w"> </span><span class="k">do</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">A</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">"The whole array A is: "</span><span class="p">,</span><span class="w"> </span><span class="nx">A</span><span class="p">);</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="nx">n</span><span class="w"> </span><span class="k">do</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">"A["</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="s">"] = "</span><span class="p">,</span><span class="w"> </span><span class="nx">A</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="nx">GpuDiagnostics</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">proc</span><span class="w"> </span><span class="nf">startCountingKernelLaunches</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nx">resetGpuDiagnostics</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nx">startGpuDiagnostics</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">proc</span><span class="w"> </span><span class="nf">numKernelLaunches</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nx">stopGpuDiagnostics</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">reduce</span><span class="w"> </span><span class="nx">getGpuDiagnostics</span><span class="p">().</span><span class="nx">kernel_launch</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nx">startCountingKernelLaunches</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">result</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nx">startCountingKernelLaunches</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">on</span><span class="w"> </span><span class="nx">here</span><span class="p">.</span><span class="nx">gpus</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">Evens</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">Evens</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">// One kernel launch from the promoted initializer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="nx">assert</span><span class="p">(</span><span class="nx">numKernelLaunches</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">use</span><span class="w"> </span><span class="nx">Math</span><span class="p">;</span><span class="w"> </span><span class="c1">// Include the 'Math' module for access to 'sin' and 'pi'
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">numSamples</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nx">i</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..#</span><span class="nx">numSamples</span><span class="p">]</span><span class="w"> </span><span class="nx">sin</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">pi</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">numSamples</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">A</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">// One kernel launch from the loop expression initializer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="nx">assert</span><span class="p">(</span><span class="nx">numKernelLaunches</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">proc</span><span class="w"> </span><span class="nf">fib</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span><span class="w"> </span><span class="kt">int</span><span class="p">):</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">fib</span><span class="p">(</span><span class="nx">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">fib</span><span class="p">(</span><span class="nx">x</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">Fibs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">fib</span><span class="p">(</span><span class="mi">0</span><span class="o">..#</span><span class="mi">20</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">Fibs</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">// One kernel launch from the promoted expression in the initializer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="nx">assert</span><span class="p">(</span><span class="nx">numKernelLaunches</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">rows</span><span class="p">,</span><span class="w"> </span><span class="nx">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">Square</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="nx">rows</span><span class="p">,</span><span class="w"> </span><span class="nx">cols</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="nx">r</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">)</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">Square</span><span class="p">.</span><span class="nx">indices</span><span class="w"> </span><span class="k">do</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nx">Square</span><span class="p">[</span><span class="nx">r</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">c</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">"Original array:"</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">Square</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">// Two kernel launches: one from initializing Square, one from the loop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="nx">assert</span><span class="p">(</span><span class="nx">numKernelLaunches</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="nx">ColSums</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="nx">cols</span><span class="p">]</span><span class="w"> </span><span class="kt">int</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">foreach</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">cols</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">rows</span><span class="w"> </span><span class="k">do</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="nx">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">Square</span><span class="p">[</span><span class="nx">r</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">ColSums</span><span class="p">[</span><span class="nx">c</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">sum</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="s">"Column sums:"</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nx">writeln</span><span class="p">(</span><span class="nx">ColSums</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">// Two kernel launches: one from initializing ColSums, one from the loop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="nx">assert</span><span class="p">(</span><span class="nx">numKernelLaunches</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w"> </span><span class="c1">// end of `on here.gpus[0]`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">coforall</span><span class="w"> </span><span class="nx">loc</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">Locales</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="nx">loc</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">coforall</span><span class="w"> </span><span class="nx">gpu</span><span class="w"> </span><span class="kd">in</span><span class="w"> </span><span class="nx">here</span><span class="p">.</span><span class="nx">gpus</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="nx">gpu</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">Evens</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nx">writeln</span><span class="p">(</span><span class="s">"Even numbers computed on "</span><span class="p">,</span><span class="w"> </span><span class="nx">gpu</span><span class="p">,</span><span class="w"> </span><span class="s">": "</span><span class="p">,</span><span class="w"> </span><span class="nx">Evens</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div>
</details>
</div>
</p>
<h3 id="appendix-what-sorts-of-problems-benefit-from-gpus">
<a href="#appendix-what-sorts-of-problems-benefit-from-gpus">Appendix: What Sorts of Problems Benefit from GPUs?</a>
</h3>
<p>A huge difference between a GPU and a CPU is the number of <em>cores</em>.
A core is the part of a processor that’s responsible for executing instructions
/ machine code. Whereas I am writing this from a computer with around 10
CPU cores, a cursory Google search indicates that the NVIDIA RTX 4070 GPU
(picked arbitrarily by searching “consumer NVIDIA GPU”)
has 5888 cores —
<span class="sidenote"><label class="sidenote-label" for="sidenote-5">over 500 times the number of cores in my CPU!</label><input class="sidenote-checkbox" id="sidenote-5" type="checkbox"/><span class="sidenote-content sidenote-right" style="margin-top: -3.5rem"><span class="sidenote-delimiter">[note:</span>In fact, because of the huge number of cores that concurrently execute code,
GPUs are an example of a <a href="https://en.wikipedia.org/wiki/Massively_parallel" rel="noopener" target="_blank">massively parallel</a> architecture.<span class="sidenote-delimiter">]</span></span></span>
Of course, a CPU core is not the same as a GPU core: GPU cores tend to be
much weaker individually.</p>
<p>For problems that can be decomposed into a large number of
<span class="sidenote"><label class="sidenote-label" for="sidenote-6">similar</label><input class="sidenote-checkbox" id="sidenote-6" type="checkbox"/><span class="sidenote-content sidenote-left"><span class="sidenote-delimiter">[note:</span>For GPUs, the sub-problems being similar is actually very significant.
A single GPU core is actually solving multiple instances of
a sub-problem <em>at the same time</em>, executing their code in lock-step.
As soon as lock-step execution is no longer possible, and two sub-problems
need different approaches, the GPU has to struggle a lot more. This problem
is called <em>thread divergence</em>.<span class="sidenote-delimiter">]</span></span></span>
pieces,
having a large number of weak cores is ideal. Each
core can receive its own share of the problem, and work on it
<span class="sidenote"><label class="sidenote-label" for="sidenote-7">independently;</label><input class="sidenote-checkbox" id="sidenote-7" type="checkbox"/><span class="sidenote-content sidenote-right"><span class="sidenote-delimiter">[note:</span>It’s possible, and not too uncommon, to have a small degree of coordination
between GPU cores when solving problems. GPUs are able allocate memory that’s
shared between cores, and to synchronize the cores’ execution. However,
this is slightly more advanced than this introductory article.<span class="sidenote-delimiter">]</span></span></span>
because each sub-problem is independent, all of the cores can be working on their
share at exactly the same time. This can result in a very significant speedup
over a single, powerful core: such a core would need to go through each
of the pieces one after another.</p>
<p>One example of a problem amenable to GPU execution is rendering an image to
a screen. In fact, as the name <em>Graphics Processing Unit</em> suggests, this
was the very problem GPUs were developed to solve. When rendering, the color
of each pixel can be computed relatively independently, based on depth and
texture information; each core of the GPU can thus be working on a handful of
pixels at a time, all in parallel, significantly speeding up the process.</p>
<p>An entire problem domain that is well-suited for GPU execution is linear algebra.
In matrix multiplication, for example, each cell in the output matrix can be
computed independently from all the other cells; once again, this means that
each GPU core can be working on a handful of cells in parallel. Many
things, including neural networks, can be formulated in terms of matrix operations;
fast linear algebra leads to faster machine learning models.</p>
<p>The descriptions above should give you a taste of <em>what</em> can be done with GPUs.
The next obvious question is <em>how</em> we can do all this with Chapel. This
brings us to the topic of this blog: getting Chapel to run code on the GPU.</p>
</div>
</main>
<div class="container">
<div class="share-view">
<h3>Share this article:</h3>
<div class="share-buttons">
<a class="button share-button" href="https://bsky.app/intent/compose?text=Check+out+this+post+entitled+%22Introduction+to+GPU+Programming+in+Chapel%22+on+the+Chapel+Programming+Language+blog%3A+https%3A%2F%2Fchapel-lang.org%2Fblog%2Fposts%2Fintro-to-gpus%2F" rel="noopener noreferrer" style="--button-color: #6cb0f9; --button-color-light: white;" target="_blank">
<img alt="Share on BlueSky" height="30" src="../../img/bluesky-logo.jpg" width="30"/>
</a>
<a class="button share-button" href="https://www.facebook.com/sharer/sharer.php?description=Check+out+this+post+entitled+%22Introduction+to+GPU+Programming+in+Chapel%22+on+the+Chapel+Programming+Language+blog%3A&amp;u=https%3A%2F%2Fchapel-lang.org%2Fblog%2Fposts%2Fintro-to-gpus%2F" rel="noopener noreferrer" style="--button-color: #3a559f; --button-color-light: white;" target="_blank">
<img alt="Share on Facebook" height="30" src="../../img/facebook-logo.png" width="30"/>
</a>
<a class="button share-button" href="https://linkedin.com/share?text=Check+out+this+post+entitled+%22Introduction+to+GPU+Programming+in+Chapel%22+on+the+Chapel+Programming+Language+blog%3A&amp;url=https%3A%2F%2Fchapel-lang.org%2Fblog%2Fposts%2Fintro-to-gpus%2F" rel="noopener noreferrer" style="--button-color: #2867b2; --button-color-light: white;" target="_blank">
<img alt="Share on LinkedIn" height="30" src="../../img/linkedin-logo.png" width="30"/>
</a>
<a class="button share-button" href="https://new.reddit.com/submit?title=Introduction+to+GPU+Programming+in+Chapel&amp;url=https%3A%2F%2Fchapel-lang.org%2Fblog%2Fposts%2Fintro-to-gpus%2F" rel="noopener noreferrer" style="--button-color: #ff4500; --button-color-light: white;" target="_blank">
<img alt="Share on Reddit" height="30" src="../../img/reddit-logo.svg" width="30"/>
</a>
<a class="button share-button" href="http://x.com/share?text=Check+out+this+post+entitled+%22Introduction+to+GPU+Programming+in+Chapel%22+on+the+Chapel+Programming+Language+blog%3A&amp;url=https%3A%2F%2Fchapel-lang.org%2Fblog%2Fposts%2Fintro-to-gpus%2F" rel="noopener noreferrer" style="--button-color: #000000; --button-color-light: #7a7a7a;" target="_blank">
<img alt="Share on X" height="30" src="../../img/x-logo.svg" width="30"/>
</a>
</div>
</div>
</div>
<nav class="container series-navigation">
<div class="series-button-wrapper next">
<a class="button" href="../../posts/gpu-data-movement/">
<span>
                    Next in series
                    <span class="series-button-name">
                        
Chapel's High-Level Support for CPU-GPU Data Transfers and Multi-GPU Programming


                    </span>
</span>
<svg class="feather">
<use xlink:href="../../feather-sprite.svg#chevrons-right"></use>
</svg>
</a>
</div>
</nav>
</body>
</html>
